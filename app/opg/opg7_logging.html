<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Docker Workshop - Datavolumer & Logging</title>

    <link rel="stylesheet" href="/node_modules/bootstrap/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="/node_modules/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="../style.css">

    <script src="/node_modules/jquery/dist/jquery.min.js"></script>
    <script src="/node_modules/bootstrap/dist/js/bootstrap.min.js"></script>

    <script type="text/javascript">
        $(document).ready(function () {
            $('#navigation').load('../navbar.html');

           /* $('.task').each(function() {
                var $id = $(this).attr("id");
                var dataElem = {"task": $id};
                $.ajax({
                    url: '/check',
                    data: { task: $id }
                }).done(function(data) {
                    $('#' + $id).append('<div>'+data+'</div>');
                });
            });*/
        });
    </script>
</head>

<body>

<div class="nav-container">
    <div id="navigation"></div>
</div>

<div class="container">
    <h1>Oppgave 7 - Datavolumer og Logging</h1>
    <p>
        Et problem man gjerne støter på når man konverterer en eksisterende applikasjon til å kjøres i en docker-container
        er hva man skal gjøre med loggfiler. I en normal Java-applikasjon er logging relativt enkelt; velg et rammeverk
        og sett opp en liten konfigurasjon, og logg til en fil. Lokasjonen for filene kan spesifiseres fritt, og selv om
        programmet avsluttes eller krasjer så vil loggfilene i de aller fleste tilfeller være intakte og aksesserbare.
    </p>
    <p>
        Når man derimot kjører programmet i en container, så vil loggfilen kun finnes inne i containeren. Dette kan være
        lite hjelpsomt dersom man for eksempel har problemer under oppstart av containeren, og det er også lite
        praktisk når man har et stort antall containere - og det er fort gjort å slette en gammel, stoppet container...
        Heldigvis finnes det en løsning for dette. Faktisk finnes det mange
        løsninger, men den enkleste er å mounte et datavolum fra host-filsystemet, som vil være persitent selv om containeren
        avslutter, og la loggene skrives til dette volumet istedenfor det interne filsystemet i docker-containeren.
    </p>
    <div class="alert alert-info">
        <b>Tips:</b> Containere som har blitt stoppet kan finnes med kommmandoen 'docker ps --filter "status=exited"'. De
        kan også startes igjen med docker start.
    </div>

    <h2>a)</h2>
    <p>
        Mount en mappe fra det lokale filsystemet til en mappe i docker-containeren, og la docker-containeren bruke
        linux-kommandoen 'touch' for å opprette en fil der når den starter opp. Filen skal da dukke opp i host-filsystemet
        når containeren startes opp, og persistere når containeren termineres! Sjekk at du finner filen der du forventer det
        med en filutforsker.
    </p>

    <h2>b)</h2>
    <p>
        Akkurat det samme kan gjøres for loggfiler som skrives til av programmer. Åpne filen 'logback.xml', som inneholder
        loggkonfigurasjonene for DockerClient, og endre pathen for loggene til mappen der du i oppgave a) mountet datavolumet.
        Under kjøring vil docker nå skrive filene til host-filsystemet. Sjekk igjen at filene dukker opp der de forventes, og at
        programmet har klart å skrive til dem.
    </p>
    <div class="alert alert-info">
        <b>NB!</b> Det kan være lurt å ha tunga rett i munnen når man kjører multiple containere i en swarm/et cluster.
        Typisk vil man ønske å mounte samme datavolum for containere som kjører samme image, men da bør man i så fall
        passe på at det ikke kjøres flere instanser på samme host. For om det skjer, så vil flere kilder skrive til de
        samme loggfilene etc, hvilket fort kan bli problematisk.
    </div>

    <h2>Bonusoppgave</h2>
    <p>
        Dersom mange containere skal lese fra de samme filene, så anbefales det å bruke såkalte data volume containers.
        Disse kjører typisk ingen applikasjoner, de eksisterer kun for å tilby sentrert tilgang til data volume mounts.
        For å teste dette, kan dere sette opp en data volume container som for eksempel inneholder team.properties med en ny
        verdi, endre workshop'ens applikasjon til å lese inn team.properties fra stien dere har plassert filen på, og kjøre
        containeren med bruk av data volume containeren. Dere skal da kunne se at ny verdi leses inn.
    </p>

    <!-- div id="fremgang">
        <h2>Fremgang</h2>
        <div id="9a" class="task">a) </div>
        <div id="9b" class="task">b) </div>
    </div -->

    <h2>Nyttige Lenker</h2>
    <a href="https://docs.docker.com/engine/userguide/containers/dockervolumes/">Docker Volumes</a>

</div>


</body>
</html>