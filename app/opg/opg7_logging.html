<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Docker Workshop - Datavolumer & Logging</title>

    <link rel="stylesheet" href="/node_modules/bootstrap/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="/node_modules/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="../style.css">

    <script src="/node_modules/jquery/dist/jquery.min.js"></script>
    <script src="/node_modules/bootstrap/dist/js/bootstrap.min.js"></script>

    <script type="text/javascript">
        $(document).ready(function () {
            $('#navigation').load('../navbar.html');

           /* $('.task').each(function() {
                var $id = $(this).attr("id");
                var dataElem = {"task": $id};
                $.ajax({
                    url: '/check',
                    data: { task: $id }
                }).done(function(data) {
                    $('#' + $id).append('<div>'+data+'</div>');
                });
            });*/
        });
    </script>
</head>

<body>

<div class="nav-container">
    <div id="navigation"></div>
</div>

<div class="container">
    <h1>Oppgave 7 - Datavolumer og Logging</h1>
    <p>
        Et problem man gjerne st&oslash;ter p&aring; n&aring;r man konverterer en eksisterende applikasjon til &aring; kj&oslash;res i en docker-container
        er hva man skal gj&oslash;re med loggfiler. I en normal Java-applikasjon er logging relativt enkelt; velg et rammeverk
        og sett opp en liten konfigurasjon, og logg til en fil. Lokasjonen for filene kan spesifiseres fritt, og selv om
        programmet avsluttes eller krasjer s&aring; vil loggfilene i de aller fleste tilfeller v&aelig;re intakte og aksesserbare.
    </p>
    <p>
        N&aring;r man derimot kj&oslash;rer programmet i en container, s&aring; vil loggfilen kun finnes inne i containeren. Dette kan v&aelig;re
        lite hjelpsomt dersom man for eksempel har problemer under oppstart av containeren, og det er ogs&aring; lite
        praktisk n&aring;r man har et stort antall containere - og det er fort gjort &aring; slette en gammel, stoppet container...
        Heldigvis finnes det en l&oslash;sning for dette. Faktisk finnes det mange
        l&oslash;sninger, men den enkleste er &aring; mounte et datavolum fra host-filsystemet, som vil v&aelig;re persitent selv om containeren
        avslutter, og la loggene skrives til dette volumet istedenfor det interne filsystemet i docker-containeren.
    </p>
    <div class="alert alert-info">
        <b>Tips:</b> Containere som har blitt stoppet kan finnes med kommmandoen 'docker ps --filter "status=exited"'. De
        kan ogs&aring; startes igjen med docker start.
    </div>

    <h2>a)</h2>
    <p>
        Mount en mappe fra det lokale filsystemet til en mappe i docker-containeren, og la docker-containeren bruke
        linux-kommandoen 'touch' for &aring; opprette en fil der n&aring;r den starter opp. Filen skal da dukke opp i host-filsystemet
        n&aring;r containeren startes opp, og persistere n&aring;r containeren termineres! Sjekk at du finner filen der du forventer det
        med en filutforsker.
    </p>
    <a name="mounting-tips">
        <div class="alert alert-warning">
            <b>Merk: </b> n&aring;r en lokal docker-host er satt som aktiv i docker-machine, vil lokale filbaner som parametere til 'docker run -v'
            referere til filbanen i den aktive docker host-en, <strong>med unntak av hjemmekatalogen</strong>. Dette er fordi
            Docker-machine p&aring; Mac/Windows alltid fors&oslash;ker &aring; mounte henholdsvis /Users /c/Users, slik at de blir tilgjengelige lokalt p&aring; host-en.
            P&aring; Linux gj&oslash;res ikke dette, men til gjengjeld kan man her bruke Docker uten en docker-machine som mellommann. Dette
            gj&oslash;res ved &aring; ikke sette noen machines som aktive ('eval "$(docker-machine env -u)"'). Om volumer skal mountes p&aring;
            remote hosts m&aring; filene enten kopieres, eller man m&aring; bruke en data volume container.
        </div>
    </a>


    <h2>b)</h2>
    <p>
        Akkurat det samme kan gj&oslash;res for loggfiler som skrives til av programmer. &aring;pne filen 'logback.xml', som inneholder
        loggkonfigurasjonene for DockerClient, og endre pathen for loggene til mappen der du i oppgave a) mountet datavolumet.
        Under kj&oslash;ring vil docker n&aring; skrive filene til host-filsystemet. Sjekk igjen at filene dukker opp der de forventes, og at
        programmet har klart &aring; skrive til dem.
    </p>
    <div class="alert alert-info">
        <b>NB!</b> Det kan v&aelig;re lurt &aring; ha tunga rett i munnen n&aring;r man kj&oslash;rer multiple containere i en swarm/et cluster.
        Typisk vil man &oslash;nske &aring; mounte samme datavolum for containere som kj&oslash;rer samme image, men da b&oslash;r man i s&aring; fall
        passe p&aring; at det ikke kj&oslash;res flere instanser p&aring; samme host. For om det skjer, s&aring; vil flere kilder skrive til de
        samme loggfilene etc, hvilket fort kan bli problematisk.
    </div>

    <h2>Bonusoppgave</h2>
    <p>
        Dersom mange containere skal lese fra de samme filene, s&aring; anbefales det &aring; bruke s&aring;kalte data volume containers.
        Disse kj&oslash;rer typisk ingen applikasjoner, de eksisterer kun for &aring; tilby sentrert tilgang til data volume mounts.
        For &aring; teste dette, kan dere sette opp en data volume container som for eksempel inneholder filen team.properties med en ny
        verdi. Endre s&aring; workshopens applikasjon til &aring; lese inn team.properties fra stien dere har plassert filen p&aring;, og kj&oslash;r
        containeren slik at den bruker den nye data volume containeren. Dere skal da kunne se at ny verdi leses inn.
    </p>
    <p>
        Vær obs på at eksemplet i den nyttige lenken under ikke faktisk knytter datavolumet til en gitt lokasjon lokalt,
        men det er nødvendig i denne bonusoppgaven. Husk derfor samme syntax (etter -v) som i foregående deloppgaver.
    </p>

    <!-- div id="fremgang">
        <h2>Fremgang</h2>
        <div id="9a" class="task">a) </div>
        <div id="9b" class="task">b) </div>
    </div -->

    <h2>Nyttige Lenker</h2>
    <a href="https://docs.docker.com/engine/userguide/containers/dockervolumes/">Docker Volumes</a>

</div>


</body>
</html>